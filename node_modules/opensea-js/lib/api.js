"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenSeaAPI = void 0;
const ethers_1 = require("ethers");
const constants_1 = require("./constants");
const utils_1 = require("./orders/utils");
const types_1 = require("./types");
const utils_2 = require("./utils/utils");
class OpenSeaAPI {
    /**
     * Create an instance of the OpenSea API
     * @param config OpenSeaAPIConfig for setting up the API, including an optional API key, Chain name, and base URL
     * @param logger Optional function for logging debug strings before and after requests are made
     */
    constructor(config, logger) {
        var _a, _b, _c;
        /**
         * Page size to use for fetching orders
         */
        this.pageSize = 20;
        this.retryDelay = 3000;
        this.apiKey = config.apiKey;
        this.chain = (_a = config.chain) !== null && _a !== void 0 ? _a : types_1.Chain.Mainnet;
        switch (config.chain) {
            case types_1.Chain.Goerli:
                this.apiBaseUrl = (_b = config.apiBaseUrl) !== null && _b !== void 0 ? _b : constants_1.API_BASE_TESTNET;
                break;
            case types_1.Chain.Mainnet:
            default:
                this.apiBaseUrl = (_c = config.apiBaseUrl) !== null && _c !== void 0 ? _c : constants_1.API_BASE_MAINNET;
                break;
        }
        // Debugging: default to nothing
        this.logger = logger !== null && logger !== void 0 ? logger : ((arg) => arg);
    }
    /**
     * Gets an order from API based on query options. Throws when no order is found.
     */
    getOrder(_a) {
        var { side, protocol = "seaport", orderDirection = "desc", orderBy = "created_date" } = _a, restOptions = __rest(_a, ["side", "protocol", "orderDirection", "orderBy"]);
        return __awaiter(this, void 0, void 0, function* () {
            const { orders } = yield this.get((0, utils_1.getOrdersAPIPath)(this.chain, protocol, side), (0, utils_1.serializeOrdersQueryOptions)(Object.assign({ limit: 1, orderBy,
                orderDirection }, restOptions)));
            if (orders.length === 0) {
                throw new Error("Not found: no matching order found");
            }
            return (0, utils_1.deserializeOrder)(orders[0]);
        });
    }
    /**
     * Gets a list of orders from API based on query options and returns orders
     * with next and previous cursors.
     */
    getOrders(_a) {
        var { side, protocol = "seaport", orderDirection = "desc", orderBy = "created_date" } = _a, restOptions = __rest(_a, ["side", "protocol", "orderDirection", "orderBy"]);
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.get((0, utils_1.getOrdersAPIPath)(this.chain, protocol, side), (0, utils_1.serializeOrdersQueryOptions)(Object.assign({ limit: this.pageSize, orderBy,
                orderDirection }, restOptions)));
            return Object.assign(Object.assign({}, response), { orders: response.orders.map(utils_1.deserializeOrder) });
        });
    }
    /**
     * Generate the data needed to fulfill a listing or an offer
     */
    generateFulfillmentData(fulfillerAddress, orderHash, protocolAddress, side) {
        return __awaiter(this, void 0, void 0, function* () {
            let payload = null;
            if (side === "ask") {
                payload = (0, utils_1.getFulfillListingPayload)(fulfillerAddress, orderHash, protocolAddress, this.chain);
            }
            else {
                payload = (0, utils_1.getFulfillOfferPayload)(fulfillerAddress, orderHash, protocolAddress, this.chain);
            }
            const response = yield this.post((0, utils_1.getFulfillmentDataPath)(side), payload);
            return response;
        });
    }
    /**
     * Send an order to be posted. Throws when the order is invalid.
     */
    postOrder(order, apiOptions, { retries = 2 } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let response;
            // TODO: Validate apiOptions. Avoid API calls that will definitely fail
            const { protocol = "seaport", side, protocolAddress } = apiOptions;
            try {
                response = yield this.post((0, utils_1.getOrdersAPIPath)(this.chain, protocol, side), Object.assign(Object.assign({}, order), { protocol_address: protocolAddress }));
            }
            catch (error) {
                _throwOrContinue(error, retries);
                yield (0, utils_2.delay)(this.retryDelay);
                return this.postOrder(order, apiOptions, { retries: retries - 1 });
            }
            return (0, utils_1.deserializeOrder)(response.order);
        });
    }
    /**
     * Build an offer
     */
    buildOffer(offererAddress, quantity, collectionSlug) {
        return __awaiter(this, void 0, void 0, function* () {
            const payload = (0, utils_1.getBuildCollectionOfferPayload)(offererAddress, quantity, collectionSlug);
            const response = yield this.post((0, utils_1.getBuildOfferPath)(), payload);
            return response;
        });
    }
    /**
     * Post collection offer
     */
    postCollectionOffer(order, slug, retries = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            const payload = (0, utils_1.getPostCollectionOfferPayload)(slug, order);
            try {
                return yield this.post((0, utils_1.getPostCollectionOfferPath)(), payload);
            }
            catch (error) {
                _throwOrContinue(error, retries);
                yield (0, utils_2.delay)(1000);
                return this.postCollectionOffer(order, slug, retries - 1);
            }
        });
    }
    /**
     * Fetch an asset from the API, throwing if none is found
     * @param tokenAddress Address of the asset's contract
     * @param tokenId The asset's token ID, or null if ERC-20
     * @param retries Number of times to retry if the service is unavailable for any reason
     */
    getAsset({ tokenAddress, tokenId, }, retries = 1) {
        return __awaiter(this, void 0, void 0, function* () {
            let json;
            try {
                json = yield this.get(`${constants_1.API_PATH}/asset/${tokenAddress}/${tokenId !== null && tokenId !== void 0 ? tokenId : 0}/`);
            }
            catch (error) {
                _throwOrContinue(error, retries);
                yield (0, utils_2.delay)(1000);
                return this.getAsset({ tokenAddress, tokenId }, retries - 1);
            }
            return (0, utils_2.assetFromJSON)(json);
        });
    }
    /**
     * Fetch list of assets from the API, returning the page of assets and the count of total assets
     * @param query Query to use for getting orders. A subset of parameters on the `OpenSeaAssetJSON` type is supported
     */
    getAssets(query = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const json = yield this.get(`${constants_1.API_PATH}/assets/`, Object.assign({ limit: this.pageSize }, query));
            return {
                assets: json.assets.map((j) => (0, utils_2.assetFromJSON)(j)),
                next: json.next,
                previous: json.previous,
                estimatedCount: json.estimated_count,
            };
        });
    }
    /**
     * Fetch a collection through the API
     */
    getCollection(slug) {
        return __awaiter(this, void 0, void 0, function* () {
            const path = (0, utils_1.getCollectionPath)(slug);
            const response = yield this.get(path);
            return (0, utils_2.collectionFromJSON)(response.collection);
        });
    }
    /**
     * Fetch list of fungible tokens from the API matching parameters
     * @param query Query to use for getting orders. A subset of parameters on the `OpenSeaAssetJSON` type is supported
     * @param page Page number, defaults to 1. Can be overridden by
     * `limit` and `offset` attributes from OpenSeaFungibleTokenQuery
     * @param retries Number of times to retry if the service is unavailable for any reason
     */
    getPaymentTokens(query = {}, page = 1, retries = 1) {
        return __awaiter(this, void 0, void 0, function* () {
            let json;
            try {
                json = yield this.get(`${constants_1.API_PATH}/tokens/`, Object.assign(Object.assign({}, query), { limit: this.pageSize, offset: (page - 1) * this.pageSize }));
            }
            catch (error) {
                _throwOrContinue(error, retries);
                yield (0, utils_2.delay)(1000);
                return this.getPaymentTokens(query, page, retries - 1);
            }
            return {
                tokens: json.map((t) => (0, utils_2.tokenFromJSON)(t)),
            };
        });
    }
    /**
     * Fetch a bundle from the API, return null if it isn't found
     * @param slug The bundle's identifier
     */
    getBundle({ slug, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const json = yield this.get(`${constants_1.API_PATH}/bundle/${slug}/`);
            return json ? (0, utils_2.assetBundleFromJSON)(json) : null;
        });
    }
    /**
     * Fetch list of bundles from the API, returning the page of bundles and the count of total bundles
     * @param query Query to use for getting orders. A subset of parameters on the `OpenSeaAssetBundleJSON` type is supported
     * @param page Page number, defaults to 1. Can be overridden by
     * `limit` and `offset` attributes from OpenSeaAssetBundleQuery
     */
    getBundles(query = {}, page = 1) {
        return __awaiter(this, void 0, void 0, function* () {
            const json = yield this.get(`${constants_1.API_PATH}/bundles/`, Object.assign(Object.assign({}, query), { limit: this.pageSize, offset: (page - 1) * this.pageSize }));
            return {
                bundles: json.bundles.map((j) => (0, utils_2.assetBundleFromJSON)(j)),
                estimatedCount: json.estimated_count,
            };
        });
    }
    /**
     * Get JSON data from API, sending auth token in headers
     * @param apiPath Path to URL endpoint under API
     * @param query Data to send. Will be stringified using QueryString
     */
    get(apiPath, query = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const qs = this.objectToSearchParams(query);
            const url = `${this.apiBaseUrl}${apiPath}?${qs}`;
            return yield this._fetch({ url });
        });
    }
    /**
     * POST JSON data to API, sending auth token in headers
     * @param apiPath Path to URL endpoint under API
     * @param body Data to send. Will be JSON.stringified
     * @param opts ethers ConnectionInfo, similar to Fetch API.
     */
    post(apiPath, body, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = Object.assign({ url: `${this.apiBaseUrl}${apiPath}` }, opts);
            return yield this._fetch(options, body);
        });
    }
    objectToSearchParams(params = {}) {
        const urlSearchParams = new URLSearchParams();
        Object.entries(params).forEach(([key, value]) => {
            if (value && Array.isArray(value)) {
                value.forEach((item) => item && urlSearchParams.append(key, item));
            }
            else if (value) {
                urlSearchParams.append(key, value);
            }
        });
        return urlSearchParams.toString();
    }
    /**
     * Get from an API Endpoint, sending auth token in headers
     * @param opts ethers ConnectionInfo, similar to Fetch API
     * @param body Optional body to send. If set, will POST, otherwise GET
     */
    _fetch(opts, body) {
        return __awaiter(this, void 0, void 0, function* () {
            const headers = Object.assign(Object.assign({ "x-app-id": "opensea-js" }, (this.apiKey ? { "X-API-KEY": this.apiKey } : {})), opts.headers);
            const req = Object.assign(Object.assign({}, opts), { headers });
            this.logger(`Sending request: ${opts.url} ${JSON.stringify(req).slice(0, 200)}...`);
            return yield ethers_1.ethers.utils.fetchJson(req, body ? JSON.stringify(body) : undefined);
        });
    }
}
exports.OpenSeaAPI = OpenSeaAPI;
function _throwOrContinue(error, retries) {
    const isUnavailable = error instanceof Error &&
        !!error.message &&
        (error.message.includes("503") || error.message.includes("429"));
    if (retries <= 0 || !isUnavailable) {
        throw error;
    }
}
//# sourceMappingURL=api.js.map
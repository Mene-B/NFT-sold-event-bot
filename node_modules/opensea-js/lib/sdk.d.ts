import { Seaport } from "@opensea/seaport-js";
import { BigNumber, BigNumberish, Wallet, providers } from "ethers";
import { OpenSeaAPI } from "./api";
import { OrderV2, PostOfferResponse } from "./orders/types";
import { Asset, ComputedFees, EventData, EventType, Chain, OpenSeaAPIConfig, OpenSeaAsset, OrderSide } from "./types";
export declare class OpenSeaSDK {
    /** Provider */
    provider: providers.JsonRpcProvider;
    /** Seaport v1.5 client */
    seaport_v1_5: Seaport;
    /** Logger function to use when debugging */
    logger: (arg: string) => void;
    /** API instance on this seaport */
    readonly api: OpenSeaAPI;
    /** The configured chain */
    readonly chain: Chain;
    private _emitter;
    private _signerOrProvider;
    /**
     * Your very own seaport.
     * Create a new instance of OpenSeaJS.
     * @param provider Provider to use for transactions. For example:
     *  `const provider = new ethers.providers.JsonRpcProvider('https://mainnet.infura.io')`
     * @param apiConfig configuration options, including `chain`
     * @param logger logger, optional, a function that will be called with debugging
     * @param wallet optional, if you'd like to use an ethers wallet for order posting
     *  information
     */
    constructor(provider: providers.JsonRpcProvider, apiConfig?: OpenSeaAPIConfig, logger?: (arg: string) => void, wallet?: Wallet);
    /**
     * Add a listener to a marketplace event.
     * @param event An event to listen for
     * @param listener A callback that will accept an object with event data
     * @param once Whether the listener should only be called once
     */
    addListener(event: EventType, listener: (data: EventData) => void, once?: boolean): void;
    /**
     * Remove an event listener, included for completeness.
     * Simply calls `.removeListener()` on an event and listener.
     * @param event The event to remove a listener for
     * @param listener The listener to remove
     */
    removeListener(event: EventType, listener: (data: EventData) => void): void;
    /**
     * Remove all event listeners. Good idea to call this when you're unmounting
     * a component that listens to events to make UI updates
     * @param event Optional EventType to remove listeners for
     */
    removeAllListeners(event?: EventType): void;
    /**
     * Wrap ETH into W-ETH.
     * W-ETH is needed for placing buy orders (making offers).
     * Emits the `WrapEth` event when the transaction is prompted.
     * @param amountInEth How much ether to wrap
     * @param accountAddress Address of the user's wallet containing the ether
     */
    wrapEth({ amountInEth, accountAddress, }: {
        amountInEth: BigNumberish;
        accountAddress: string;
    }): Promise<void>;
    /**
     * Unwrap W-ETH into ETH.
     * Emits the `UnwrapWeth` event when the transaction is prompted.
     * @param amountInEth How much W-ETH to unwrap
     * @param accountAddress Address of the user's wallet containing the W-ETH
     */
    unwrapWeth({ amountInEth, accountAddress, }: {
        amountInEth: BigNumberish;
        accountAddress: string;
    }): Promise<void>;
    private getAmountWithBasisPointsApplied;
    private getFees;
    private getAssetItems;
    /**
     * Create a buy order to make an offer on an asset.
     * @param options Options for creating the buy order
     * @param options.asset The asset to trade
     * @param options.accountAddress Address of the maker's wallet
     * @param options.startAmount Value of the offer, in units of the payment token (or wrapped ETH if no payment token address specified)
     * @param options.quantity The number of assets to bid for (if fungible or semi-fungible). Defaults to 1. In units, not base units, e.g. not wei
     * @param options.domain An optional domain to be hashed and included in the first four bytes of the random salt.
     * @param options.salt Arbitrary salt. If not passed in, a random salt will be generated with the first four bytes being the domain hash or empty.
     * @param options.expirationTime Expiration time for the order, in seconds
     * @param options.paymentTokenAddress Optional address for using an ERC-20 token in the order. If unspecified, defaults to WETH
     */
    createBuyOrder({ asset, accountAddress, startAmount, quantity, domain, salt, expirationTime, paymentTokenAddress, }: {
        asset: Asset;
        accountAddress: string;
        startAmount: BigNumberish;
        quantity?: BigNumberish;
        domain?: string;
        salt?: BigNumberish;
        expirationTime?: BigNumberish;
        paymentTokenAddress?: string;
    }): Promise<OrderV2>;
    /**
     * Create a sell order to auction an asset.
     * @param options Options for creating the sell order
     * @param options.asset The asset to trade
     * @param options.accountAddress Address of the maker's wallet
     * @param options.startAmount Price of the asset at the start of the auction. Units are in the amount of a token above the token's decimal places (integer part). For example, for ether, expected units are in ETH, not wei.
     * @param options.endAmount Optional price of the asset at the end of its expiration time. Units are in the amount of a token above the token's decimal places (integer part). For example, for ether, expected units are in ETH, not wei.
     * @param options.quantity The number of assets to sell (if fungible or semi-fungible). Defaults to 1. In units, not base units, e.g. not wei.
     * @param options.domain An optional domain to be hashed and included in the first four bytes of the random salt.
     * @param options.salt Arbitrary salt. If not passed in, a random salt will be generated with the first four bytes being the domain hash or empty.
     * @param options.listingTime Optional time when the order will become fulfillable, in UTC seconds. Undefined means it will start now.
     * @param options.expirationTime Expiration time for the order, in UTC seconds.
     * @param options.paymentTokenAddress Address of the ERC-20 token to accept in return. If undefined or null, uses Ether.
     * @param options.buyerAddress Optional address that's allowed to purchase this item. If specified, no other address will be able to take the order, unless its value is the null address.
     */
    createSellOrder({ asset, accountAddress, startAmount, endAmount, quantity, domain, salt, listingTime, expirationTime, paymentTokenAddress, buyerAddress, }: {
        asset: Asset;
        accountAddress: string;
        startAmount: BigNumberish;
        endAmount?: BigNumberish;
        quantity?: BigNumberish;
        domain?: string;
        salt?: BigNumberish;
        listingTime?: number;
        expirationTime?: number;
        paymentTokenAddress?: string;
        buyerAddress?: string;
    }): Promise<OrderV2>;
    /**
     * Create a collection offer
     */
    createCollectionOffer({ collectionSlug, accountAddress, amount, quantity, domain, salt, expirationTime, paymentTokenAddress, }: {
        collectionSlug: string;
        accountAddress: string;
        amount: BigNumberish;
        quantity: number;
        domain?: string;
        salt?: BigNumberish;
        expirationTime?: number | string;
        paymentTokenAddress: string;
    }): Promise<PostOfferResponse | null>;
    private fulfillPrivateOrder;
    /**
     * Fullfill or "take" an order for an asset, either a buy or sell order
     * @param options fullfillment options
     * @param options.order The order to fulfill, a.k.a. "take"
     * @param options.accountAddress The taker's wallet address
     * @param options.recipientAddress The optional address to receive the order's item(s) or curriencies. If not specified, defaults to accountAddress
     * @param options.domain An optional domain to be hashed and included at the end of fulfillment calldata
     * @returns Transaction hash for fulfilling the order
     */
    fulfillOrder({ order, accountAddress, recipientAddress, domain, }: {
        order: OrderV2;
        accountAddress: string;
        recipientAddress?: string;
        domain?: string;
    }): Promise<string>;
    private cancelSeaportOrders;
    /**
     * Cancel an order on-chain, preventing it from ever being fulfilled.
     * @param order The order to cancel
     * @param accountAddress The order maker's wallet address
     * @param domain An optional domain to be hashed and included at the end of fulfillment calldata
     */
    cancelOrder({ order, accountAddress, domain, }: {
        order: OrderV2;
        accountAddress: string;
        domain?: string;
    }): Promise<void>;
    /**
     * Returns whether an order is fulfillable.
     * An order may not be fulfillable if a target item's transfer function
     * is locked for some reason, e.g. an item is being rented within a game
     * or trading has been locked for an item type.
     * @param order Order to check
     * @param accountAddress The account address that will be fulfilling the order
     */
    isOrderFulfillable({ order, accountAddress, }: {
        order: OrderV2;
        accountAddress: string;
    }): Promise<boolean>;
    /**
     * Get an account's balance of any Asset.
     * @param accountAddress Account address to check
     * @param asset The Asset to check balance for
     * @param retries How many times to retry if balance is 0
     */
    getBalance({ accountAddress, asset }: {
        accountAddress: string;
        asset: Asset;
    }, retries?: number): Promise<BigNumber>;
    /**
     * Compute the fees for an order
     * @param asset Asset to use for fees. May be blank ONLY for multi-collection bundles.
     * @param side The side of the order (buy or sell)
     */
    computeFees({ asset, }: {
        asset?: OpenSeaAsset;
        side: OrderSide;
    }): Promise<ComputedFees>;
    /**
     * Instead of signing an off-chain order, you can approve an order
     * with on on-chain transaction using this method
     * @param order Order to approve
     * @param domain An optional domain to be hashed and included at the end of fulfillment calldata
     * @returns Transaction hash of the approval transaction
     */
    approveOrder(order: OrderV2, domain?: string): Promise<string>;
    /**
     * Compute the `basePrice` and `extra` parameters to be used to price an order.
     * Also validates the expiration time and auction type.
     * @param tokenAddress Address of the ERC-20 token to use for trading.
     * Use the null address for ETH
     * @param expirationTime When the auction expires, or 0 if never.
     * @param startAmount The base value for the order, in the token's main units (e.g. ETH instead of wei)
     * @param endAmount The end value for the order, in the token's main units (e.g. ETH instead of wei). If unspecified, the order's `extra` attribute will be 0
     * @param waitingForBestCounterOrder
     * @param englishAuctionReservePrice
     */
    private _getPriceParameters;
    private _dispatch;
    private _confirmTransaction;
}

"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenSeaSDK = void 0;
const EventEmitter = require("events");
const seaport_js_1 = require("@opensea/seaport-js");
const constants_1 = require("@opensea/seaport-js/lib/constants");
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const api_1 = require("./api");
const constants_2 = require("./constants");
const privateListings_1 = require("./orders/privateListings");
const utils_2 = require("./orders/utils");
const contracts_1 = require("./typechain/contracts");
const types_1 = require("./types");
const tokens_1 = require("./utils/tokens");
const utils_3 = require("./utils/utils");
class OpenSeaSDK {
    /**
     * Your very own seaport.
     * Create a new instance of OpenSeaJS.
     * @param provider Provider to use for transactions. For example:
     *  `const provider = new ethers.providers.JsonRpcProvider('https://mainnet.infura.io')`
     * @param apiConfig configuration options, including `chain`
     * @param logger logger, optional, a function that will be called with debugging
     * @param wallet optional, if you'd like to use an ethers wallet for order posting
     *  information
     */
    constructor(provider, apiConfig = {}, logger, wallet) {
        var _a;
        this.getAmountWithBasisPointsApplied = (amount, basisPoints) => {
            return amount.mul(basisPoints).div(constants_2.INVERSE_BASIS_POINT).toString();
        };
        // API config
        (_a = apiConfig.chain) !== null && _a !== void 0 ? _a : (apiConfig.chain = types_1.Chain.Mainnet);
        this.chain = apiConfig.chain;
        this.api = new api_1.OpenSeaAPI(apiConfig);
        this.provider = provider;
        this._signerOrProvider = wallet !== null && wallet !== void 0 ? wallet : this.provider;
        this.seaport_v1_5 = new seaport_js_1.Seaport(this._signerOrProvider, {
            overrides: { defaultConduitKey: constants_1.OPENSEA_CONDUIT_KEY },
        });
        // Emit events
        this._emitter = new EventEmitter();
        // Logger: default to no logging if fn not provided
        this.logger = logger !== null && logger !== void 0 ? logger : ((arg) => arg);
    }
    /**
     * Add a listener to a marketplace event.
     * @param event An event to listen for
     * @param listener A callback that will accept an object with event data
     * @param once Whether the listener should only be called once
     */
    addListener(event, listener, once = false) {
        if (once) {
            this._emitter.once(event, listener);
        }
        else {
            this._emitter.addListener(event, listener);
        }
    }
    /**
     * Remove an event listener, included for completeness.
     * Simply calls `.removeListener()` on an event and listener.
     * @param event The event to remove a listener for
     * @param listener The listener to remove
     */
    removeListener(event, listener) {
        this._emitter.removeListener(event, listener);
    }
    /**
     * Remove all event listeners. Good idea to call this when you're unmounting
     * a component that listens to events to make UI updates
     * @param event Optional EventType to remove listeners for
     */
    removeAllListeners(event) {
        this._emitter.removeAllListeners(event);
    }
    /**
     * Wrap ETH into W-ETH.
     * W-ETH is needed for placing buy orders (making offers).
     * Emits the `WrapEth` event when the transaction is prompted.
     * @param amountInEth How much ether to wrap
     * @param accountAddress Address of the user's wallet containing the ether
     */
    wrapEth({ amountInEth, accountAddress, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const token = (0, tokens_1.getCanonicalWrappedEther)(this.chain);
            const value = (0, utils_1.parseEther)(ethers_1.FixedNumber.from(amountInEth).toString());
            this._dispatch(types_1.EventType.WrapEth, { accountAddress, amount: value });
            const wethContract = new ethers_1.Contract(token.address, ["function deposit() payable"], this._signerOrProvider);
            wethContract.connect(this.provider);
            try {
                const transaction = yield wethContract.deposit({ value });
                yield this._confirmTransaction(transaction.hash, types_1.EventType.WrapEth, "Wrapping ETH");
            }
            catch (error) {
                console.error(error);
                this._dispatch(types_1.EventType.TransactionDenied, { error, accountAddress });
            }
        });
    }
    /**
     * Unwrap W-ETH into ETH.
     * Emits the `UnwrapWeth` event when the transaction is prompted.
     * @param amountInEth How much W-ETH to unwrap
     * @param accountAddress Address of the user's wallet containing the W-ETH
     */
    unwrapWeth({ amountInEth, accountAddress, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const token = (0, tokens_1.getCanonicalWrappedEther)(this.chain);
            const amount = (0, utils_1.parseEther)(ethers_1.FixedNumber.from(amountInEth).toString());
            this._dispatch(types_1.EventType.UnwrapWeth, { accountAddress, amount });
            const wethContract = new ethers_1.Contract(token.address, ["function withdraw(uint wad) public"], this._signerOrProvider);
            wethContract.connect(this.provider);
            try {
                const transaction = yield wethContract.withdraw(amount);
                yield this._confirmTransaction(transaction.hash, types_1.EventType.UnwrapWeth, "Unwrapping W-ETH");
            }
            catch (error) {
                console.error(error);
                this._dispatch(types_1.EventType.TransactionDenied, { error, accountAddress });
            }
        });
    }
    getFees({ collection, paymentTokenAddress, startAmount, endAmount, }) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            // Seller fee basis points
            const osFees = (_a = collection.fees) === null || _a === void 0 ? void 0 : _a.openseaFees;
            const creatorFees = (_b = collection.fees) === null || _b === void 0 ? void 0 : _b.sellerFees;
            const openseaSellerFeeBasisPoints = (0, utils_3.feesToBasisPoints)(osFees);
            const collectionSellerFeeBasisPoints = (0, utils_3.feesToBasisPoints)(creatorFees);
            // Seller basis points
            const sellerBasisPoints = constants_2.INVERSE_BASIS_POINT -
                openseaSellerFeeBasisPoints -
                collectionSellerFeeBasisPoints;
            const getConsiderationItem = (basisPoints, recipient) => {
                return {
                    token: paymentTokenAddress,
                    amount: this.getAmountWithBasisPointsApplied(startAmount, basisPoints),
                    endAmount: this.getAmountWithBasisPointsApplied(endAmount !== null && endAmount !== void 0 ? endAmount : startAmount, basisPoints),
                    recipient,
                };
            };
            const getConsiderationItemsFromFeeCategory = (feeCategory) => {
                return Array.from(feeCategory.entries()).map(([recipient, basisPoints]) => {
                    return getConsiderationItem(basisPoints, recipient);
                });
            };
            return {
                sellerFee: getConsiderationItem(sellerBasisPoints),
                openseaSellerFees: openseaSellerFeeBasisPoints > 0 && collection.fees
                    ? getConsiderationItemsFromFeeCategory(osFees)
                    : [],
                collectionSellerFees: collectionSellerFeeBasisPoints > 0 && collection.fees
                    ? getConsiderationItemsFromFeeCategory(creatorFees)
                    : [],
            };
        });
    }
    getAssetItems(assets, quantities = []) {
        return assets.map((asset, index) => {
            var _a, _b;
            return ({
                itemType: (0, utils_3.getAssetItemType)(asset.assetContract.tokenStandard),
                token: (0, utils_3.getAddressAfterRemappingSharedStorefrontAddressToLazyMintAdapterAddress)(asset.tokenAddress),
                identifier: (_a = asset.tokenId) !== null && _a !== void 0 ? _a : undefined,
                amount: (_b = quantities[index].toString()) !== null && _b !== void 0 ? _b : "1",
            });
        });
    }
    /**
     * Create a buy order to make an offer on an asset.
     * @param options Options for creating the buy order
     * @param options.asset The asset to trade
     * @param options.accountAddress Address of the maker's wallet
     * @param options.startAmount Value of the offer, in units of the payment token (or wrapped ETH if no payment token address specified)
     * @param options.quantity The number of assets to bid for (if fungible or semi-fungible). Defaults to 1. In units, not base units, e.g. not wei
     * @param options.domain An optional domain to be hashed and included in the first four bytes of the random salt.
     * @param options.salt Arbitrary salt. If not passed in, a random salt will be generated with the first four bytes being the domain hash or empty.
     * @param options.expirationTime Expiration time for the order, in seconds
     * @param options.paymentTokenAddress Optional address for using an ERC-20 token in the order. If unspecified, defaults to WETH
     */
    createBuyOrder({ asset, accountAddress, startAmount, quantity = 1, domain, salt, expirationTime, paymentTokenAddress, }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!asset.tokenId) {
                throw new Error("Asset must have a tokenId");
            }
            paymentTokenAddress =
                paymentTokenAddress !== null && paymentTokenAddress !== void 0 ? paymentTokenAddress : constants_2.WETH_ADDRESS_BY_NETWORK[this.chain];
            const openseaAsset = yield this.api.getAsset(asset);
            const considerationAssetItems = this.getAssetItems([openseaAsset], [ethers_1.BigNumber.from(quantity !== null && quantity !== void 0 ? quantity : 1)]);
            const { basePrice } = yield this._getPriceParameters(types_1.OrderSide.Buy, paymentTokenAddress, expirationTime !== null && expirationTime !== void 0 ? expirationTime : (0, utils_3.getMaxOrderExpirationTimestamp)(), startAmount);
            const { openseaSellerFees, collectionSellerFees: collectionSellerFees } = yield this.getFees({
                collection: openseaAsset.collection,
                paymentTokenAddress,
                startAmount: basePrice,
            });
            const considerationFeeItems = [
                ...openseaSellerFees,
                ...collectionSellerFees,
            ];
            const { executeAllActions } = yield this.seaport_v1_5.createOrder({
                offer: [
                    {
                        token: paymentTokenAddress,
                        amount: basePrice.toString(),
                    },
                ],
                consideration: [...considerationAssetItems, ...considerationFeeItems],
                endTime: expirationTime !== undefined
                    ? ethers_1.BigNumber.from(expirationTime).toString()
                    : (0, utils_3.getMaxOrderExpirationTimestamp)().toString(),
                zone: constants_2.DEFAULT_ZONE_BY_NETWORK[this.chain],
                domain,
                salt: ethers_1.BigNumber.from(salt !== null && salt !== void 0 ? salt : 0).toString(),
                restrictedByZone: false,
                allowPartialFills: true,
            }, accountAddress);
            const order = yield executeAllActions();
            return this.api.postOrder(order, {
                protocol: "seaport",
                protocolAddress: utils_2.DEFAULT_SEAPORT_CONTRACT_ADDRESS,
                side: "bid",
            });
        });
    }
    /**
     * Create a sell order to auction an asset.
     * @param options Options for creating the sell order
     * @param options.asset The asset to trade
     * @param options.accountAddress Address of the maker's wallet
     * @param options.startAmount Price of the asset at the start of the auction. Units are in the amount of a token above the token's decimal places (integer part). For example, for ether, expected units are in ETH, not wei.
     * @param options.endAmount Optional price of the asset at the end of its expiration time. Units are in the amount of a token above the token's decimal places (integer part). For example, for ether, expected units are in ETH, not wei.
     * @param options.quantity The number of assets to sell (if fungible or semi-fungible). Defaults to 1. In units, not base units, e.g. not wei.
     * @param options.domain An optional domain to be hashed and included in the first four bytes of the random salt.
     * @param options.salt Arbitrary salt. If not passed in, a random salt will be generated with the first four bytes being the domain hash or empty.
     * @param options.listingTime Optional time when the order will become fulfillable, in UTC seconds. Undefined means it will start now.
     * @param options.expirationTime Expiration time for the order, in UTC seconds.
     * @param options.paymentTokenAddress Address of the ERC-20 token to accept in return. If undefined or null, uses Ether.
     * @param options.buyerAddress Optional address that's allowed to purchase this item. If specified, no other address will be able to take the order, unless its value is the null address.
     */
    createSellOrder({ asset, accountAddress, startAmount, endAmount, quantity = 1, domain, salt, listingTime, expirationTime, paymentTokenAddress = ethers_1.ethers.constants.AddressZero, buyerAddress, }) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!asset.tokenId) {
                throw new Error("Asset must have a tokenId");
            }
            const openseaAsset = yield this.api.getAsset(asset);
            const offerAssetItems = this.getAssetItems([openseaAsset], [ethers_1.BigNumber.from(quantity !== null && quantity !== void 0 ? quantity : 1)]);
            const { basePrice, endPrice } = yield this._getPriceParameters(types_1.OrderSide.Sell, paymentTokenAddress, expirationTime !== null && expirationTime !== void 0 ? expirationTime : (0, utils_3.getMaxOrderExpirationTimestamp)(), startAmount, endAmount !== null && endAmount !== void 0 ? endAmount : undefined);
            const { sellerFee, openseaSellerFees, collectionSellerFees: collectionSellerFees, } = yield this.getFees({
                collection: openseaAsset.collection,
                paymentTokenAddress,
                startAmount: basePrice,
                endAmount: endPrice,
            });
            const considerationFeeItems = [
                sellerFee,
                ...openseaSellerFees,
                ...collectionSellerFees,
            ];
            if (buyerAddress) {
                considerationFeeItems.push(...(0, privateListings_1.getPrivateListingConsiderations)(offerAssetItems, buyerAddress));
            }
            const { executeAllActions } = yield this.seaport_v1_5.createOrder({
                offer: offerAssetItems,
                consideration: considerationFeeItems,
                startTime: listingTime === null || listingTime === void 0 ? void 0 : listingTime.toString(),
                endTime: (_a = expirationTime === null || expirationTime === void 0 ? void 0 : expirationTime.toString()) !== null && _a !== void 0 ? _a : (0, utils_3.getMaxOrderExpirationTimestamp)().toString(),
                zone: constants_2.DEFAULT_ZONE_BY_NETWORK[this.chain],
                domain,
                salt: ethers_1.BigNumber.from(salt !== null && salt !== void 0 ? salt : 0).toString(),
                restrictedByZone: false,
                allowPartialFills: true,
            }, accountAddress);
            const order = yield executeAllActions();
            return this.api.postOrder(order, {
                protocol: "seaport",
                protocolAddress: utils_2.DEFAULT_SEAPORT_CONTRACT_ADDRESS,
                side: "ask",
            });
        });
    }
    /**
     * Create a collection offer
     */
    createCollectionOffer({ collectionSlug, accountAddress, amount, quantity, domain, salt, expirationTime, paymentTokenAddress, }) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const collection = yield this.api.getCollection(collectionSlug);
            const buildOfferResult = yield this.api.buildOffer(accountAddress, quantity, collectionSlug);
            const item = buildOfferResult.partialParameters.consideration[0];
            const convertedConsiderationItem = {
                itemType: item.itemType,
                token: item.token,
                identifier: item.identifierOrCriteria,
                amount: item.startAmount,
            };
            const { basePrice } = yield this._getPriceParameters(types_1.OrderSide.Buy, paymentTokenAddress, expirationTime !== null && expirationTime !== void 0 ? expirationTime : (0, utils_3.getMaxOrderExpirationTimestamp)(), amount);
            const { openseaSellerFees, collectionSellerFees: collectionSellerFees } = yield this.getFees({
                collection,
                paymentTokenAddress,
                startAmount: basePrice,
                endAmount: basePrice,
            });
            const considerationItems = [
                convertedConsiderationItem,
                ...openseaSellerFees,
                ...collectionSellerFees,
            ];
            const payload = {
                offerer: accountAddress,
                offer: [
                    {
                        token: paymentTokenAddress,
                        amount: basePrice.toString(),
                    },
                ],
                consideration: considerationItems,
                endTime: (_a = expirationTime === null || expirationTime === void 0 ? void 0 : expirationTime.toString()) !== null && _a !== void 0 ? _a : (0, utils_3.getMaxOrderExpirationTimestamp)().toString(),
                zone: buildOfferResult.partialParameters.zone,
                domain,
                salt: ethers_1.BigNumber.from(salt !== null && salt !== void 0 ? salt : 0).toString(),
                restrictedByZone: true,
                allowPartialFills: true,
            };
            const { executeAllActions } = yield this.seaport_v1_5.createOrder(payload, accountAddress);
            const order = yield executeAllActions();
            return this.api.postCollectionOffer(order, collectionSlug);
        });
    }
    fulfillPrivateOrder({ order, accountAddress, domain, }) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!(0, utils_3.isValidProtocol)(order.protocolAddress)) {
                throw new Error("Unsupported protocol");
            }
            if (!((_a = order.taker) === null || _a === void 0 ? void 0 : _a.address)) {
                throw new Error("Order is not a private listing must have a taker address");
            }
            const counterOrder = (0, privateListings_1.constructPrivateListingCounterOrder)(order.protocolData, order.taker.address);
            const fulfillments = (0, privateListings_1.getPrivateListingFulfillments)(order.protocolData);
            const transaction = yield this.seaport_v1_5
                .matchOrders({
                orders: [order.protocolData, counterOrder],
                fulfillments,
                overrides: {
                    value: counterOrder.parameters.offer[0].startAmount,
                },
                accountAddress,
                domain,
            })
                .transact();
            const transactionReceipt = yield transaction.wait();
            yield this._confirmTransaction(transactionReceipt.transactionHash, types_1.EventType.MatchOrders, "Fulfilling order");
            return transactionReceipt.transactionHash;
        });
    }
    /**
     * Fullfill or "take" an order for an asset, either a buy or sell order
     * @param options fullfillment options
     * @param options.order The order to fulfill, a.k.a. "take"
     * @param options.accountAddress The taker's wallet address
     * @param options.recipientAddress The optional address to receive the order's item(s) or curriencies. If not specified, defaults to accountAddress
     * @param options.domain An optional domain to be hashed and included at the end of fulfillment calldata
     * @returns Transaction hash for fulfilling the order
     */
    fulfillOrder({ order, accountAddress, recipientAddress, domain, }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(0, utils_3.isValidProtocol)(order.protocolAddress)) {
                throw new Error("Unsupported protocol");
            }
            if (order.orderHash) {
                const result = yield this.api.generateFulfillmentData(accountAddress, order.orderHash, order.protocolAddress, order.side);
                const signature = result.fulfillment_data.orders[0].signature;
                order.clientSignature = signature;
                order.protocolData.signature = signature;
            }
            const isPrivateListing = !!order.taker;
            if (isPrivateListing) {
                if (recipientAddress) {
                    throw new Error("Private listings cannot be fulfilled with a recipient address");
                }
                return this.fulfillPrivateOrder({
                    order,
                    accountAddress,
                    domain,
                });
            }
            const { executeAllActions } = yield this.seaport_v1_5.fulfillOrder({
                order: order.protocolData,
                accountAddress,
                recipientAddress,
                domain,
            });
            const transaction = yield executeAllActions();
            yield this._confirmTransaction(transaction.hash, types_1.EventType.MatchOrders, "Fulfilling order");
            return transaction.hash;
        });
    }
    cancelSeaportOrders({ orders, accountAddress, domain, protocolAddress, }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!protocolAddress) {
                protocolAddress = utils_2.DEFAULT_SEAPORT_CONTRACT_ADDRESS;
            }
            const transaction = yield this.seaport_v1_5
                .cancelOrders(orders, accountAddress, domain)
                .transact();
            return transaction.hash;
        });
    }
    /**
     * Cancel an order on-chain, preventing it from ever being fulfilled.
     * @param order The order to cancel
     * @param accountAddress The order maker's wallet address
     * @param domain An optional domain to be hashed and included at the end of fulfillment calldata
     */
    cancelOrder({ order, accountAddress, domain, }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(0, utils_3.isValidProtocol)(order.protocolAddress)) {
                throw new Error("Unsupported protocol");
            }
            this._dispatch(types_1.EventType.CancelOrder, { orderV2: order, accountAddress });
            // Transact and get the transaction hash
            const transactionHash = yield this.cancelSeaportOrders({
                orders: [order.protocolData.parameters],
                accountAddress,
                domain,
                protocolAddress: order.protocolAddress,
            });
            // Await transaction confirmation
            yield this._confirmTransaction(transactionHash, types_1.EventType.CancelOrder, "Cancelling order");
        });
    }
    /**
     * Returns whether an order is fulfillable.
     * An order may not be fulfillable if a target item's transfer function
     * is locked for some reason, e.g. an item is being rented within a game
     * or trading has been locked for an item type.
     * @param order Order to check
     * @param accountAddress The account address that will be fulfilling the order
     */
    isOrderFulfillable({ order, accountAddress, }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(0, utils_3.isValidProtocol)(order.protocolAddress)) {
                throw new Error("Unsupported protocol");
            }
            try {
                const isValid = yield this.seaport_v1_5
                    .validate([order.protocolData], accountAddress)
                    .callStatic();
                return !!isValid;
            }
            catch (error) {
                if ((0, utils_3.hasErrorCode)(error) && error.code === "CALL_EXCEPTION") {
                    return false;
                }
                throw error;
            }
        });
    }
    /**
     * Get an account's balance of any Asset.
     * @param accountAddress Account address to check
     * @param asset The Asset to check balance for
     * @param retries How many times to retry if balance is 0
     */
    getBalance({ accountAddress, asset }, retries = 1) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (asset.tokenStandard == types_1.TokenStandard.ERC20 ||
                asset.tokenStandard == types_1.TokenStandard.ERC1155) {
                const contract = new ethers_1.ethers.Contract(asset.tokenAddress, asset.tokenStandard == types_1.TokenStandard.ERC20
                    ? contracts_1.ERC20__factory.createInterface()
                    : contracts_1.ERC1155__factory.createInterface(), this.provider);
                const count = yield contract.methods
                    .balanceOf(accountAddress, (_a = asset.tokenId) !== null && _a !== void 0 ? _a : undefined)
                    .call();
                if (count !== undefined) {
                    return count;
                }
            }
            else if (asset.tokenStandard == types_1.TokenStandard.ERC721) {
                const contract = new ethers_1.ethers.Contract(asset.tokenAddress, contracts_1.ERC721__factory.createInterface(), this.provider);
                try {
                    const owner = yield contract.methods.ownerOf(asset.tokenId).call();
                    if (owner) {
                        return owner.toLowerCase() == accountAddress.toLowerCase()
                            ? ethers_1.BigNumber.from(1)
                            : ethers_1.BigNumber.from(0);
                    }
                    // eslint-disable-next-line no-empty
                }
                catch (_b) { }
            }
            else {
                // Missing ownership call - skip check to allow listings
                // by default
                throw new Error("Missing ownership schema for this asset type");
            }
            if (retries <= 0) {
                throw new Error("Unable to get current owner from smart contract");
            }
            else {
                yield (0, utils_3.delay)(500);
                // Recursively check owner again
                return yield this.getBalance({ accountAddress, asset }, retries - 1);
            }
        });
    }
    /**
     * Compute the fees for an order
     * @param asset Asset to use for fees. May be blank ONLY for multi-collection bundles.
     * @param side The side of the order (buy or sell)
     */
    computeFees({ asset, }) {
        return __awaiter(this, void 0, void 0, function* () {
            const openseaBuyerFeeBasisPoints = 0;
            let openseaSellerFeeBasisPoints = 0;
            const devBuyerFeeBasisPoints = 0;
            let devSellerFeeBasisPoints = 0;
            if (asset) {
                const fees = asset.collection.fees;
                openseaSellerFeeBasisPoints = +(0, utils_3.feesToBasisPoints)(fees === null || fees === void 0 ? void 0 : fees.openseaFees);
                devSellerFeeBasisPoints = +(0, utils_3.feesToBasisPoints)(fees === null || fees === void 0 ? void 0 : fees.sellerFees);
            }
            return {
                totalBuyerFeeBasisPoints: openseaBuyerFeeBasisPoints + devBuyerFeeBasisPoints,
                totalSellerFeeBasisPoints: openseaSellerFeeBasisPoints + devSellerFeeBasisPoints,
                openseaBuyerFeeBasisPoints,
                openseaSellerFeeBasisPoints,
                devBuyerFeeBasisPoints,
                devSellerFeeBasisPoints,
            };
        });
    }
    /**
     * Instead of signing an off-chain order, you can approve an order
     * with on on-chain transaction using this method
     * @param order Order to approve
     * @param domain An optional domain to be hashed and included at the end of fulfillment calldata
     * @returns Transaction hash of the approval transaction
     */
    approveOrder(order, domain) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(0, utils_3.isValidProtocol)(order.protocolAddress)) {
                throw new Error("Unsupported protocol");
            }
            this._dispatch(types_1.EventType.ApproveOrder, {
                orderV2: order,
                accountAddress: order.maker.address,
            });
            const transaction = yield this.seaport_v1_5
                .validate([order.protocolData], order.maker.address, domain)
                .transact();
            yield this._confirmTransaction(transaction.hash, types_1.EventType.ApproveOrder, "Approving order");
            return transaction.hash;
        });
    }
    /**
     * Compute the `basePrice` and `extra` parameters to be used to price an order.
     * Also validates the expiration time and auction type.
     * @param tokenAddress Address of the ERC-20 token to use for trading.
     * Use the null address for ETH
     * @param expirationTime When the auction expires, or 0 if never.
     * @param startAmount The base value for the order, in the token's main units (e.g. ETH instead of wei)
     * @param endAmount The end value for the order, in the token's main units (e.g. ETH instead of wei). If unspecified, the order's `extra` attribute will be 0
     * @param waitingForBestCounterOrder
     * @param englishAuctionReservePrice
     */
    _getPriceParameters(orderSide, tokenAddress, expirationTime, startAmount, endAmount, waitingForBestCounterOrder = false, englishAuctionReservePrice) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const isEther = tokenAddress === ethers_1.ethers.constants.AddressZero;
            let paymentToken;
            if (!isEther) {
                const { tokens } = yield this.api.getPaymentTokens({
                    address: tokenAddress.toLowerCase(),
                });
                paymentToken = tokens[0];
            }
            const decimals = (_a = paymentToken === null || paymentToken === void 0 ? void 0 : paymentToken.decimals) !== null && _a !== void 0 ? _a : 18;
            const startAmountWei = ethers_1.ethers.utils.parseUnits(startAmount.toString(), decimals);
            const endAmountWei = endAmount
                ? ethers_1.ethers.utils.parseUnits(endAmount.toString(), decimals)
                : undefined;
            const priceDiffWei = endAmountWei !== undefined
                ? startAmountWei.sub(endAmountWei)
                : ethers_1.BigNumber.from(0);
            const basePrice = startAmountWei;
            const endPrice = endAmountWei;
            const extra = priceDiffWei;
            const reservePrice = englishAuctionReservePrice
                ? ethers_1.ethers.utils.parseUnits(startAmount.toString(), decimals)
                : undefined;
            // Validation
            if (startAmount == null || startAmountWei.lt(0)) {
                throw new Error(`Starting price must be a number >= 0`);
            }
            if (!isEther && !paymentToken) {
                throw new Error(`No ERC-20 token found for ${tokenAddress}`);
            }
            if (isEther && waitingForBestCounterOrder) {
                throw new Error(`English auctions must use wrapped ETH or an ERC-20 token.`);
            }
            if (isEther && orderSide === types_1.OrderSide.Buy) {
                throw new Error(`Offers must use wrapped ETH or an ERC-20 token.`);
            }
            if (priceDiffWei.lt(0)) {
                throw new Error("End price must be less than or equal to the start price.");
            }
            if (priceDiffWei.gt(0) && ethers_1.BigNumber.from(expirationTime).isZero()) {
                throw new Error("Expiration time must be set if order will change in price.");
            }
            const reservePriceIsDefinedAndNonZero = reservePrice && !reservePrice.isZero();
            if (reservePriceIsDefinedAndNonZero && !waitingForBestCounterOrder) {
                throw new Error("Reserve prices may only be set on English auctions.");
            }
            if (reservePriceIsDefinedAndNonZero && (reservePrice === null || reservePrice === void 0 ? void 0 : reservePrice.lt(startAmountWei))) {
                throw new Error("Reserve price must be greater than or equal to the start amount.");
            }
            return { basePrice, extra, paymentToken, reservePrice, endPrice };
        });
    }
    _dispatch(event, data) {
        this._emitter.emit(event, data);
    }
    _confirmTransaction(transactionHash, event, description) {
        return __awaiter(this, void 0, void 0, function* () {
            const transactionEventData = { transactionHash, event };
            this.logger(`Transaction started: ${description}`);
            try {
                this._dispatch(types_1.EventType.TransactionCreated, transactionEventData);
                yield this.provider.waitForTransaction(transactionHash);
                this.logger(`Transaction succeeded: ${description}`);
                this._dispatch(types_1.EventType.TransactionConfirmed, transactionEventData);
            }
            catch (error) {
                this.logger(`Transaction failed: ${description}`);
                this._dispatch(types_1.EventType.TransactionFailed, Object.assign(Object.assign({}, transactionEventData), { error }));
                throw error;
            }
        });
    }
}
exports.OpenSeaSDK = OpenSeaSDK;
//# sourceMappingURL=sdk.js.map
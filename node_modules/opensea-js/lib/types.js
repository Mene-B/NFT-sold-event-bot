"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HowToCall = exports.SafelistStatus = exports.TokenStandard = exports.AssetContractType = exports.SaleKind = exports.FeeMethod = exports.OrderSide = exports.Chain = exports.EventType = void 0;
/**
 * Events emitted by the SDK. There are five types:
 * 1. Transaction events, which tell you when a new transaction was
 *    created, confirmed, denied, or failed.
 * 2. pre-transaction events, which are named (like "WrapEth") and indicate
 *    that ethers is asking for a signature on a transaction that needs to occur before
 *    an order is made or fulfilled. This includes approval events and account
 *    initialization.
 * 3. Basic actions: matching, cancelling, and creating orders.
 *    The "CreateOrder" event fires when a signature is being prompted
 *    to create an off-chain order. The "OrderDenied" event fires when a signature
 *    request is denied by the user.
 * 4. The "TransferAll" event, which fires when a user is about to directly
 *    transfer one or more assets to another account
 */
var EventType;
(function (EventType) {
    // Transactions and signature requests
    EventType["TransactionCreated"] = "TransactionCreated";
    EventType["TransactionConfirmed"] = "TransactionConfirmed";
    EventType["TransactionDenied"] = "TransactionDenied";
    EventType["TransactionFailed"] = "TransactionFailed";
    // Pre-transaction events
    EventType["InitializeAccount"] = "InitializeAccount";
    EventType["WrapEth"] = "WrapEth";
    EventType["UnwrapWeth"] = "UnwrapWeth";
    EventType["ApproveCurrency"] = "ApproveCurrency";
    EventType["ApproveAsset"] = "ApproveAsset";
    EventType["ApproveAllAssets"] = "ApproveAllAssets";
    EventType["UnapproveCurrency"] = "UnapproveCurrency";
    // Basic actions: matching orders, creating orders, and cancelling orders
    EventType["MatchOrders"] = "MatchOrders";
    EventType["CancelOrder"] = "CancelOrder";
    EventType["BulkCancelExistingOrders"] = "BulkCancelExistingOrders";
    EventType["ApproveOrder"] = "ApproveOrder";
    EventType["CreateOrder"] = "CreateOrder";
    // When the signature request for an order is denied
    EventType["OrderDenied"] = "OrderDenied";
    // When transferring one or more assets
    EventType["TransferAll"] = "TransferAll";
    EventType["TransferOne"] = "TransferOne";
    // When wrapping or unwrapping NFTs
    EventType["WrapAssets"] = "WrapAssets";
    EventType["UnwrapAssets"] = "UnwrapAssets";
    EventType["LiquidateAssets"] = "LiquidateAssets";
    EventType["PurchaseAssets"] = "PurchaseAssets";
})(EventType || (exports.EventType = EventType = {}));
var Chain;
(function (Chain) {
    Chain["Mainnet"] = "main";
    Chain["Goerli"] = "goerli";
})(Chain || (exports.Chain = Chain = {}));
/**
 * Seaport order side: buy or sell.
 */
var OrderSide;
(function (OrderSide) {
    OrderSide[OrderSide["Buy"] = 0] = "Buy";
    OrderSide[OrderSide["Sell"] = 1] = "Sell";
})(OrderSide || (exports.OrderSide = OrderSide = {}));
/**
 * Fee method
 * ProtocolFee: Charge maker fee to seller and charge taker fee to buyer.
 * SplitFee: Maker fees are deducted from the token amount that the maker receives. Taker fees are extra tokens that must be paid by the taker.
 */
var FeeMethod;
(function (FeeMethod) {
    FeeMethod[FeeMethod["ProtocolFee"] = 0] = "ProtocolFee";
    FeeMethod[FeeMethod["SplitFee"] = 1] = "SplitFee";
})(FeeMethod || (exports.FeeMethod = FeeMethod = {}));
/**
 * Type of sale.
 */
var SaleKind;
(function (SaleKind) {
    SaleKind[SaleKind["FixedPrice"] = 0] = "FixedPrice";
    SaleKind[SaleKind["DutchAuction"] = 1] = "DutchAuction";
})(SaleKind || (exports.SaleKind = SaleKind = {}));
/**
 * Types of asset contracts
 * Given by the asset_contract_type in the OpenSea API
 */
var AssetContractType;
(function (AssetContractType) {
    AssetContractType["Fungible"] = "fungible";
    AssetContractType["SemiFungible"] = "semi-fungible";
    AssetContractType["NonFungible"] = "non-fungible";
    AssetContractType["Unknown"] = "unknown";
})(AssetContractType || (exports.AssetContractType = AssetContractType = {}));
/**
 * Token standards
 */
var TokenStandard;
(function (TokenStandard) {
    TokenStandard["ERC20"] = "ERC20";
    TokenStandard["ERC721"] = "ERC721";
    TokenStandard["ERC1155"] = "ERC1155";
})(TokenStandard || (exports.TokenStandard = TokenStandard = {}));
/**
 * The collection's approval status within OpenSea.
 * Can be not_requested (brand new collections)
 * requested (collections that requested safelisting on our site)
 * approved (collections that are approved on our site and can be found in search results)
 * verified (verified collections)
 */
var SafelistStatus;
(function (SafelistStatus) {
    SafelistStatus["NOT_REQUESTED"] = "not_requested";
    SafelistStatus["REQUESTED"] = "requested";
    SafelistStatus["APPROVED"] = "approved";
    SafelistStatus["VERIFIED"] = "verified";
    SafelistStatus["DISABLED_TOP_TRENDING"] = "disabled_top_trending";
})(SafelistStatus || (exports.SafelistStatus = SafelistStatus = {}));
/**
 * Defines set of possible auctions types
 */
var AuctionType;
(function (AuctionType) {
    AuctionType["Dutch"] = "dutch";
    AuctionType["English"] = "english";
    AuctionType["MinPrice"] = "min_price";
})(AuctionType || (AuctionType = {}));
/**
 * Defines the possible types of asset events that can take place
 */
var AssetEventType;
(function (AssetEventType) {
    AssetEventType["AuctionCreated"] = "created";
    AssetEventType["AuctionSuccessful"] = "successful";
    AssetEventType["AuctionCancelled"] = "cancelled";
    AssetEventType["OfferEntered"] = "offer_entered";
    AssetEventType["BidEntered"] = "bid_entered";
    AssetEventType["BidWithdraw"] = "bid_withdraw";
    AssetEventType["AssetTransfer"] = "transfer";
    AssetEventType["AssetApprove"] = "approve";
    AssetEventType["CompositionCreated"] = "composition_created";
    AssetEventType["Custom"] = "custom";
    AssetEventType["Payout"] = "payout";
})(AssetEventType || (AssetEventType = {}));
var HowToCall;
(function (HowToCall) {
    HowToCall[HowToCall["Call"] = 0] = "Call";
    HowToCall[HowToCall["DelegateCall"] = 1] = "DelegateCall";
    HowToCall[HowToCall["StaticCall"] = 2] = "StaticCall";
    HowToCall[HowToCall["Create"] = 3] = "Create";
})(HowToCall || (exports.HowToCall = HowToCall = {}));
//# sourceMappingURL=types.js.map
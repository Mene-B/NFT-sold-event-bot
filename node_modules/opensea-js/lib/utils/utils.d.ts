import { ItemType } from "@opensea/seaport-js/lib/constants";
import { BigNumber, ethers } from "ethers";
import { AssetEvent, OpenSeaAccount, OpenSeaAsset, OpenSeaAssetBundle, OpenSeaAssetContract, OpenSeaCollection, OpenSeaFungibleToken, OpenSeaUser, Order, TokenStandard, Transaction, UnsignedOrder } from "../types";
export declare const assetFromJSON: (asset: any) => OpenSeaAsset;
export declare const assetEventFromJSON: (assetEvent: any) => AssetEvent;
export declare const transactionFromJSON: (transaction: any) => Transaction;
export declare const accountFromJSON: (account: any) => OpenSeaAccount;
export declare const userFromJSON: (user: any) => OpenSeaUser;
export declare const assetBundleFromJSON: (asset_bundle: any) => OpenSeaAssetBundle;
export declare const assetContractFromJSON: (asset_contract: any) => OpenSeaAssetContract;
export declare const collectionFromJSON: (collection: any) => OpenSeaCollection;
export declare const tokenFromJSON: (token: any) => OpenSeaFungibleToken;
/**
 * Estimate gas usage for a transaction.
 * @param provider The Provider
 * @param from Address sending transaction
 * @param to Destination contract address
 * @param data Data to send to contract
 * @param value Value in ETH to send with data
 */
export declare function estimateGas(provider: ethers.providers.Provider, { from, to, data, value }: ethers.Transaction): Promise<BigNumber>;
/**
 * Assign an order and a new matching order to their buy/sell sides
 * @param order Original order
 * @param matchingOrder The result of _makeMatchingOrder
 */
export declare function assignOrdersToSides(order: Order, matchingOrder: UnsignedOrder): {
    buy: Order;
    sell: Order;
};
/**
 * Delay using setTimeout
 * @param ms milliseconds to wait
 */
export declare function delay(ms: number): Promise<unknown>;
/**
 * Get special-case approval addresses for an erc721 contract
 * @param erc721Contract contract to check
 */
export declare function getNonCompliantApprovalAddress(erc721Contract: ethers.Contract, tokenId: string, _accountAddress: string): Promise<string | undefined>;
export declare const merkleValidatorByNetwork: {
    main: string;
    goerli: null;
};
/**
 * The longest time that an order is valid for is one month from the current date
 * @returns unix timestamp
 */
export declare const getMaxOrderExpirationTimestamp: () => number;
interface ErrorWithCode extends Error {
    code: string;
}
export declare const hasErrorCode: (error: unknown) => error is ErrorWithCode;
export declare const getAssetItemType: (tokenStandard?: TokenStandard) => ItemType.ERC20 | ItemType.ERC721 | ItemType.ERC1155;
/**
 * Checks if the token address is the shared storefront address and if so replaces
 * that address with the lazy mint adapter addres. Otherwise, returns the input token address
 * @param tokenAddress token address
 * @returns input token address or lazy mint adapter address
 */
export declare const getAddressAfterRemappingSharedStorefrontAddressToLazyMintAdapterAddress: (tokenAddress: string) => string;
/**
 * Sums up the basis points for an Opensea or seller fee map and returns the
 * single numeric value if the map is not empty. Otherwise, it returns 0
 * @param fees a `Fees` submap holding fees (either Fees.openseaFees
 *  or Fees.sellerFees)
 * @returns sum of basis points in a fee map
 */
export declare const feesToBasisPoints: (fees: Map<string, number> | undefined) => number;
/**
 * Checks if a protocol address is valid.
 * @param protocolAddress The protocol address
 */
export declare const isValidProtocol: (protocolAddress: string) => boolean;
export {};

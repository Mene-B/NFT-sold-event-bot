"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isValidProtocol = exports.feesToBasisPoints = exports.getAddressAfterRemappingSharedStorefrontAddressToLazyMintAdapterAddress = exports.getAssetItemType = exports.hasErrorCode = exports.getMaxOrderExpirationTimestamp = exports.merkleValidatorByNetwork = exports.getNonCompliantApprovalAddress = exports.delay = exports.assignOrdersToSides = exports.estimateGas = exports.tokenFromJSON = exports.collectionFromJSON = exports.assetContractFromJSON = exports.assetBundleFromJSON = exports.userFromJSON = exports.accountFromJSON = exports.transactionFromJSON = exports.assetEventFromJSON = exports.assetFromJSON = void 0;
const constants_1 = require("@opensea/seaport-js/lib/constants");
const ethers_1 = require("ethers");
const constants_2 = require("../constants");
const types_1 = require("../types");
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const assetFromJSON = (asset) => {
    const isAnimated = asset.image_url && asset.image_url.endsWith(".gif");
    const isSvg = asset.image_url && asset.image_url.endsWith(".svg");
    const fromJSON = {
        tokenId: asset.token_id.toString(),
        tokenAddress: asset.asset_contract.address,
        name: asset.name,
        description: asset.description,
        owner: asset.owner,
        assetContract: (0, exports.assetContractFromJSON)(asset.asset_contract),
        collection: (0, exports.collectionFromJSON)(asset.collection),
        isPresale: asset.is_presale,
        // Don't use previews if it's a special image
        imageUrl: isAnimated || isSvg
            ? asset.image_url
            : asset.image_preview_url || asset.image_url,
        imagePreviewUrl: asset.image_preview_url,
        imageUrlOriginal: asset.image_original_url,
        imageUrlThumbnail: asset.image_thumbnail_url,
        animationUrl: asset.animation_url,
        animationUrlOriginal: asset.animation_original_url,
        externalLink: asset.external_link,
        openseaLink: asset.permalink,
        traits: asset.traits,
        numSales: asset.num_sales,
        lastSale: asset.last_sale ? (0, exports.assetEventFromJSON)(asset.last_sale) : null,
        backgroundColor: asset.background_color
            ? `#${asset.background_color}`
            : null,
    };
    return fromJSON;
};
exports.assetFromJSON = assetFromJSON;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const assetEventFromJSON = (assetEvent) => {
    return {
        eventType: assetEvent.event_type,
        eventTimestamp: assetEvent.event_timestamp,
        auctionType: assetEvent.auction_type,
        totalPrice: assetEvent.total_price,
        transaction: assetEvent.transaction
            ? (0, exports.transactionFromJSON)(assetEvent.transaction)
            : null,
        paymentToken: assetEvent.payment_token
            ? (0, exports.tokenFromJSON)(assetEvent.payment_token)
            : null,
    };
};
exports.assetEventFromJSON = assetEventFromJSON;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const transactionFromJSON = (transaction) => {
    return {
        fromAccount: (0, exports.accountFromJSON)(transaction.from_account),
        toAccount: (0, exports.accountFromJSON)(transaction.to_account),
        createdDate: new Date(`${transaction.created_date}Z`),
        modifiedDate: new Date(`${transaction.modified_date}Z`),
        transactionHash: transaction.transaction_hash,
        transactionIndex: transaction.transaction_index,
        blockNumber: transaction.block_number,
        blockHash: transaction.block_hash,
        timestamp: new Date(`${transaction.timestamp}Z`),
    };
};
exports.transactionFromJSON = transactionFromJSON;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const accountFromJSON = (account) => {
    return {
        address: account.address,
        config: account.config,
        profileImgUrl: account.profile_img_url,
        user: account.user ? (0, exports.userFromJSON)(account.user) : null,
    };
};
exports.accountFromJSON = accountFromJSON;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const userFromJSON = (user) => {
    return {
        username: user.username,
    };
};
exports.userFromJSON = userFromJSON;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const assetBundleFromJSON = (asset_bundle) => {
    const fromJSON = {
        maker: asset_bundle.maker,
        assets: asset_bundle.assets ? asset_bundle.assets.map(exports.assetFromJSON) : [],
        assetContract: asset_bundle.asset_contract
            ? (0, exports.assetContractFromJSON)(asset_bundle.asset_contract)
            : undefined,
        name: asset_bundle.name,
        slug: asset_bundle.slug,
        description: asset_bundle.description,
        externalLink: asset_bundle.external_link,
        permalink: asset_bundle.permalink,
    };
    return fromJSON;
};
exports.assetBundleFromJSON = assetBundleFromJSON;
const assetContractFromJSON = (
// eslint-disable-next-line @typescript-eslint/no-explicit-any
asset_contract) => {
    return {
        name: asset_contract.name,
        description: asset_contract.description,
        type: asset_contract.asset_contract_type,
        tokenStandard: asset_contract.schema_name,
        address: asset_contract.address,
        tokenSymbol: asset_contract.symbol,
        buyerFeeBasisPoints: +asset_contract.buyer_fee_basis_points,
        sellerFeeBasisPoints: +asset_contract.seller_fee_basis_points,
        openseaBuyerFeeBasisPoints: +asset_contract.opensea_buyer_fee_basis_points,
        openseaSellerFeeBasisPoints: +asset_contract.opensea_seller_fee_basis_points,
        devBuyerFeeBasisPoints: +asset_contract.dev_buyer_fee_basis_points,
        devSellerFeeBasisPoints: +asset_contract.dev_seller_fee_basis_points,
        imageUrl: asset_contract.image_url,
        externalLink: asset_contract.external_link,
        wikiLink: asset_contract.wiki_link,
    };
};
exports.assetContractFromJSON = assetContractFromJSON;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const collectionFromJSON = (collection) => {
    var _a, _b, _c;
    const createdDate = new Date(`${collection.created_date}Z`);
    return {
        createdDate,
        name: collection.name,
        description: collection.description,
        slug: collection.slug,
        editors: collection.editors,
        hidden: collection.hidden,
        featured: collection.featured,
        featuredImageUrl: collection.featured_image_url,
        displayData: collection.display_data,
        safelistRequestStatus: collection.safelist_request_status,
        paymentTokens: ((_a = collection.payment_tokens) !== null && _a !== void 0 ? _a : []).map(exports.tokenFromJSON),
        openseaBuyerFeeBasisPoints: +collection.opensea_buyer_fee_basis_points,
        openseaSellerFeeBasisPoints: +collection.opensea_seller_fee_basis_points,
        devBuyerFeeBasisPoints: +collection.dev_buyer_fee_basis_points,
        devSellerFeeBasisPoints: +collection.dev_seller_fee_basis_points,
        payoutAddress: collection.payout_address,
        imageUrl: collection.image_url,
        largeImageUrl: collection.large_image_url,
        stats: collection.stats,
        traitStats: collection.traits,
        externalLink: collection.external_url,
        wikiLink: collection.wiki_url,
        fees: {
            openseaFees: new Map(Object.entries((_b = collection.fees.opensea_fees) !== null && _b !== void 0 ? _b : {})),
            sellerFees: new Map(Object.entries((_c = collection.fees.seller_fees) !== null && _c !== void 0 ? _c : {})),
        },
    };
};
exports.collectionFromJSON = collectionFromJSON;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const tokenFromJSON = (token) => {
    const fromJSON = {
        name: token.name,
        symbol: token.symbol,
        decimals: token.decimals,
        address: token.address,
        imageUrl: token.image_url,
        ethPrice: token.eth_price,
        usdPrice: token.usd_price,
    };
    return fromJSON;
};
exports.tokenFromJSON = tokenFromJSON;
/**
 * Estimate gas usage for a transaction.
 * @param provider The Provider
 * @param from Address sending transaction
 * @param to Destination contract address
 * @param data Data to send to contract
 * @param value Value in ETH to send with data
 */
function estimateGas(provider, { from, to, data, value = ethers_1.BigNumber.from(0) }) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield provider.estimateGas({
            from,
            to,
            value: value.toString(),
            data,
        });
    });
}
exports.estimateGas = estimateGas;
/**
 * Assign an order and a new matching order to their buy/sell sides
 * @param order Original order
 * @param matchingOrder The result of _makeMatchingOrder
 */
function assignOrdersToSides(order, matchingOrder) {
    const isSellOrder = order.side == types_1.OrderSide.Sell;
    let buy;
    let sell;
    if (!isSellOrder) {
        buy = order;
        sell = Object.assign(Object.assign({}, matchingOrder), { v: buy.v, r: buy.r, s: buy.s });
    }
    else {
        sell = order;
        buy = Object.assign(Object.assign({}, matchingOrder), { v: sell.v, r: sell.r, s: sell.s });
    }
    return { buy, sell };
}
exports.assignOrdersToSides = assignOrdersToSides;
/**
 * Delay using setTimeout
 * @param ms milliseconds to wait
 */
function delay(ms) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((res) => setTimeout(res, ms));
    });
}
exports.delay = delay;
/**
 * Get special-case approval addresses for an erc721 contract
 * @param erc721Contract contract to check
 */
function getNonCompliantApprovalAddress(erc721Contract, tokenId, _accountAddress) {
    return __awaiter(this, void 0, void 0, function* () {
        const results = yield Promise.allSettled([
            // CRYPTOKITTIES check
            erc721Contract.methods.kittyIndexToApproved(tokenId).call(),
            // Etherbots check
            erc721Contract.methods.partIndexToApproved(tokenId).call(),
        ]);
        return results.filter(Boolean)[0].status;
    });
}
exports.getNonCompliantApprovalAddress = getNonCompliantApprovalAddress;
exports.merkleValidatorByNetwork = {
    [types_1.Chain.Mainnet]: constants_2.MERKLE_VALIDATOR_MAINNET,
    [types_1.Chain.Goerli]: null,
};
/**
 * The longest time that an order is valid for is one month from the current date
 * @returns unix timestamp
 */
const getMaxOrderExpirationTimestamp = () => {
    const maxExpirationDate = new Date();
    maxExpirationDate.setMonth(maxExpirationDate.getMonth() + constants_2.MAX_EXPIRATION_MONTHS);
    maxExpirationDate.setDate(maxExpirationDate.getDate() - 1);
    return Math.round(maxExpirationDate.getTime() / 1000);
};
exports.getMaxOrderExpirationTimestamp = getMaxOrderExpirationTimestamp;
const hasErrorCode = (error) => {
    const untypedError = error;
    return !!untypedError.code;
};
exports.hasErrorCode = hasErrorCode;
const getAssetItemType = (tokenStandard) => {
    switch (tokenStandard) {
        case "ERC20":
            return constants_1.ItemType.ERC20;
        case "ERC721":
            return constants_1.ItemType.ERC721;
        case "ERC1155":
            return constants_1.ItemType.ERC1155;
        default:
            throw new Error(`Unknown schema name: ${tokenStandard}`);
    }
};
exports.getAssetItemType = getAssetItemType;
const SHARED_STOREFRONT_ADDRESSES = new Set([
    constants_2.SHARED_STOREFRONT_ADDRESS_MAINNET.toLowerCase(),
    constants_2.SHARED_STOREFRONT_ADDRESS_GOERLI.toLowerCase(),
]);
/**
 * Checks if the token address is the shared storefront address and if so replaces
 * that address with the lazy mint adapter addres. Otherwise, returns the input token address
 * @param tokenAddress token address
 * @returns input token address or lazy mint adapter address
 */
const getAddressAfterRemappingSharedStorefrontAddressToLazyMintAdapterAddress = (tokenAddress) => {
    return SHARED_STOREFRONT_ADDRESSES.has(tokenAddress.toLowerCase())
        ? constants_2.SHARED_STOREFRONT_LAZY_MINT_ADAPTER_CROSS_CHAIN_ADDRESS
        : tokenAddress;
};
exports.getAddressAfterRemappingSharedStorefrontAddressToLazyMintAdapterAddress = getAddressAfterRemappingSharedStorefrontAddressToLazyMintAdapterAddress;
/**
 * Sums up the basis points for an Opensea or seller fee map and returns the
 * single numeric value if the map is not empty. Otherwise, it returns 0
 * @param fees a `Fees` submap holding fees (either Fees.openseaFees
 *  or Fees.sellerFees)
 * @returns sum of basis points in a fee map
 */
const feesToBasisPoints = (fees) => {
    if (!fees) {
        return 0;
    }
    return Array.from(fees.values()).reduce((sum, basisPoints) => basisPoints + sum, 0);
};
exports.feesToBasisPoints = feesToBasisPoints;
/**
 * Checks if a protocol address is valid.
 * @param protocolAddress The protocol address
 */
const isValidProtocol = (protocolAddress) => {
    const checkSumAddress = ethers_1.ethers.utils.getAddress(protocolAddress);
    const validProtocolAddresses = [constants_1.CROSS_CHAIN_SEAPORT_V1_5_ADDRESS].map((address) => ethers_1.ethers.utils.getAddress(address));
    return validProtocolAddresses.includes(checkSumAddress);
};
exports.isValidProtocol = isValidProtocol;
//# sourceMappingURL=utils.js.map